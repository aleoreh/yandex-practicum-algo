# Dequeue
## Принцип работы алгоритма

### Основные понятия

- по часовой стрелке - вперёд, увеличение
- против часовой стрелки - назад, уменьшение
- maxSize - максимальный размер очереди
- size - текущий размер очереди
- front - индекс одного конца очереди (в эту позицию будет вставлен элемент при вставке в начало; при извлечении из начала будет извлечён предшествующий элемент)
- back - индекс другого конца очереди (в эту позицию будет вставлен элемент при вставке в конец; при извлечении из конца будет извлечён следующий элемент)
- items - элементы очереди

### Как это работает

`front` и `back` указывают на те индексы, к которые будут вставляться значения при `pushFront` и `pushBack` соответственно. Когда значение вставляется в начало, `front` смещается назад; в конец - `back` смещается вперёд. При извлечении значений - наоборот, при этом при извлечении с начала берётся значение из индекса, следующего за `front`, при извлечении с конца - из индекса, предшествующего `back` . Смещение происходит циклически.
При инициализации структуры установим `front` на последний индекс массива, `back` - на первый
Операции не выполняются, если текущий размер очереди равен нулю (при извлечении) или максимальному размеру очереди (при вставке).

Имеем пустую очередь:
```
[ - - - ]
  b   f
```
(индексы `b`, `f` означают положение `front` и `back`)

- `pushFront(1)` в индекс $f$ устанавливаем $1$, смещаем его назад
```
[ - - 1 ]
  b f
```
- `pushBack(2)` в индекс $b$ устанавливаем $2$, смещаем его вперёд
```
[ 2 - 1 ]
    bf
```
- `pushBack(3)` в индекс $b$ устанавливаем $3$, смещаем его вперёд
```
[ 2 3 1 ]
    f b
```
- `pullFront()` результат = 1 - берём результат из индекса $f+1$, смещаем его вперёд
```
[ 2 3 - ]
      fb
```
- `pullFront()` результат = 2 - берём результат из индекса $f+1$, смещаем его вперёд
```
[ - 3 - ]
  f   b
```
- `pullBack()` результат = 3 - берём результат из индекса $b-1$, смещаем его назад
```
[ - - - ]
  f b
```

## Доказательство корректности

### Извлечение из начала/конца очереди идёт в порядке, обратном вставке

Индекс, в который вставляется значение, и из которого оно извлекается, зависит от положения указателя `front`; при вставке он смещается назад, при извлечении - вперёд. Шаг всегда равен единице. Поэтому извлечение всегда происходит обратно вставке.
То же справедливо для операций с концом очереди.

### При вставке значений не произойдёт перезаписи уже существующих

При вставке значения счётчик размера очереди увеличивается на единицу, а при достижении максимального размера вставка запрещена

## Временная сложность

### Временная сложность команд

- `pushFront`, `pushBack` 
	- операция сравнения - `O(1)`
	- установка значения по индексу - `O(1)`
	- присвоение переменной (константное количество раз) - `O(1) * C`
	- арифметическая операция - `O(1)`

```
O(1) + O(1) + O(1) * C + O(1) = O(1)`
```

- `popFront`, `popBack`
	- операция сравнения - `O(1)`
	- арифметическая операция - `O(1)`
	- присвоение переменной (константное количество раз) - `O(1) * C`
	- получение значения по индексу - `O(1)`

```
O(1) + O(1) + O(1) * C + O(1) = O(1)
```

### Общая временная сложность

Пусть количество переданных команд - `n`

Тогда общая временная сложность алгоритма составляет
```
O(1) * n = O(n)
```

## Пространственная сложность

Пусть:
- `m` - максимальное количество команд
- `p` - передано команд вставки
- `d` - передано команд удаления
- `N` - количество элементов дека

Каждая команда может вставить не более одного элемента. Удаление из пустого дека запрещено, вставка в дек с максимальным количеством элементов `m` запрещена

Тогда количество элементов дека `N` будет равно
```
N = p - d, 0 <= N <= m
```

Размер элемента не зависит от количества элементов, поэтому пространственная сложность одного элемента составляет `O(1)`

Пространственная сложность дополнительной памяти для хранения структуры напрямую зависит от `N` (для каждого элемента нужно хранить адрес в памяти) и равна, с учётом хранения данных, необходимых для работы массива:

```
O(C) + O(C)*N = O(N), где C - константа
```

Обратим внимание, что размер памяти для хранения самого размера массива (по условию задачи - не более 5000) не превысит размера для представления целого числа \[-2^53 + 1, 2^53 - 1\], поэтому примем его за константу

И при количество элементов `N` имеем пространственную сложность всего дека как сумму сложностей дополнительной памяти и самих данных:

```
O(N) + O(1)*p - O(1)*d = O(N) + O(1)*(p - d) = O(N) + O(1)*N = O(N), где N не превышает m
```
